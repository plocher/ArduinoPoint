#!/usr/bin/python
import sys
import controlpoint.ingest
import controlpoint.format

# -------------------------------------------------------------------------------
def printHeader(cp):
    print "/*"
    print " *  Autogenerated Control Point code for"
    print " *"
    print controlpoint.format.boxed_text(" *\t", cp["cpname"] + " Field Unit", "*", 4)
    print " *"
    print " *"
    print " *  Copyright 2013-2015 John Plocher "
    print " *  Attribution-NonCommercial-ShareAlike 4.0 International (CC BY-NC-SA 4.0)"
    print " *"
    print controlpoint.format.table(cp["controltable"], 'Control Packet', cpname, 8)
    print " *"
    print controlpoint.format.table(cp["indicationtable"], 'Indication Packet', cpname, 8)
    print " *"
    print controlpoint.format.table(cp["fieldtable"], 'Physical IO', cpname, 18)
    print " *"
    print controlpoint.format.expander(cp["expandertable"], 'I2C Expanders', cpname, 18)
    print " *"
    print " */"
    print ""

# -------------------------------------------------------------------------------

def printDefinitions(me):
    print ""
    print "#define {}\t{}".format("NODE_ME",                    "NODE_" + me["cpname"].upper())
    print ""
    print "#define {}\t{}".format(controlpoint.format.M(me["cpname"],"PORTS"),        str(len(me["exp"])))
    print "#define LNET_TX_PIN  7"
    print "#define LNET_RX_PIN  8"
    if ("common" in me["code"]):
        print me["code"]["common"]["code"]
    else :
        print "// No user defines found"
    print ""
    print "int determineAspect(int signalHead);             // User defined"
    print "int knockdownSignal(int signalName);             // User defined"
    print "void debugCallBack(boolean somethingchanged);    // User defined"
    print ""

    print controlpoint.format.numDefines(me)
    print ""
    print controlpoint.format.numFunctions(me)
    print ""
    print "#ifdef HASLCD"
    print "#include <LiquidTWI.h>"
    print "LiquidTWI lcd(7);  // Set the LCD I2C address"
    print "#endif"
    print "boolean localcontrol = true;  // need to add support for local-vs-dispatcher control, till then, punt"

    print ""
    print "I2Cextender m[" + controlpoint.format.M(me["cpname"], "PORTS") + "];"
    print ""

    print "// Appliances (TrackCircuits, Switches, Maintainers, Signals and Heads)"
    print controlpoint.format.applianceDefines(me["tc"])
    print controlpoint.format.applianceDefines(me["sw"])
    print controlpoint.format.applianceDefines(me["mc"])
    print controlpoint.format.applianceDefines(me["sig"])

    counter=0
    for item in me["sig"]:
        headlist=me["sig"][item]["heads"]
        for head in headlist:
            print "#define "+ me["sig"][item][str(head)+"longname"] + "\t" + str(counter)
            counter += 1

    print ""
    print "// Controls"
    print controlpoint.format.codelineDefines(me["ctl"])
    print ""
    print "// Indications"
    print controlpoint.format.codelineDefines(me["ind"])
    print ""
    print "// Field"
    print controlpoint.format.codelineDefines(me["field"])
    print '''
#define toBit(x)    ((x) % 8)
#define toByte(x)   ((x) / 8)
    '''
    print ("TrackCircuit track[{}] = {{").format(controlpoint.format.M_Appliance(me["cpname"], me["tcName"]))
    for item in me["tc"]:
        s="\tTrackCircuit(\"{i}\",\t&m[toByte({f})],\ttoBit({f}))," +"\t\t\t// {n}"
        print s.format(i=item,
                       f=str(me["tc"][item]["fieldlongname"]),
                       n=str(me["tc"][item]["name"]))
    print "};"

    print ("Switch sw[{}] = {{").format(controlpoint.format.M_Appliance(me["cpname"], me["swName"]))
    for item in me["sw"]:
        f=me["sw"][item]["field"]
        s="\tSwitch(\"{i}\",\t\t&m[toByte({n})],\ttoBit({n}),\t toBit({r}),\t toBit({m})),\t// {l}"
        print s.format(i=item,
                       n=str(f["normallongname"]),
                       r=str(f["reverselongname"]),
                       m=str(f["motorlongname"]),
                       l=str(me["sw"][item]["name"]))
    print "};"

    print ("Maintainer mc[{}] = {{").format(controlpoint.format.M_Appliance(me["cpname"], me["mcName"]))
    for item in me["mc"]:
        s="\tMaintainer(\"{i}\",\t&m[toByte({f})],\ttoBit({f})),\t\t\t// {n}"
        print s.format(i=item,
                       f=str(me["mc"][item]["fieldlongname"]),
                       n=str(me["mc"][item]["name"]))
    print "};"

    print ("RRSignal sig[{}] = {{").format(controlpoint.format.M_Appliance(me["cpname"], me["sigName"]))
    for item in me["sig"]:
        s="\tRRSignal(\"{i}\"),\t\t\t\t\t\t// {l}"
        print s.format(i=item ,
                       l=str(me["sig"][item]["name"]))
    print "};"

    print ("RRSignalHead head[{}] = {{").format(controlpoint.format.M_Appliance(me["cpname"], me["hName"]))
    for item in me["sig"]:
        headlist=me["sig"][item]["heads"]
        for head in headlist:
            sys.stdout.write("\tRRSignalHead(\"{}\",\t".format(head ))
            headfields = me["sig"][item][head]
            pre=''
            for hf in headfields:
                hfname=("{}_F{}").format(me["cpname"], hf)
                if pre == '':
                    sys.stdout.write("&m[toByte({n})]".format(n=str(hfname)))
                    pre=",\t"
                sys.stdout.write(("{p}toBit({n})").format(p=pre, n=str(hfname)))
            print "),"
    print "};"


# -------------------------------------------------------------------------------
def printFunctions(me):
    print '''
void initI2Cextender( I2Cextender *m ) {
        Wire.begin();

        for (int x = 0; x < getNumPorts(); x++) {
            m[x]       = I2Cextender();
        }'''
    print ""
    for i, item in enumerate(me["expandertable"]):
        if item: print "\t" + item["code"]
    print "};"

    if ("determineAspect" in me["code"]):
        print me["code"]["determineAspect"]["code"]
    else :
        print "int determineAspect(int signalHead) { return RRSignalHead::STOP; }   // Routine not found in CP definition"
    if ("knockdownSignal" in me["code"]):
        print me["code"]["knockdownSignal"]["code"]
    else :
        print "int knockdownSignal(int signalName) { return 0; }                    // Routine not found in CP definition"

    print '''
boolean processSignals() {
        boolean somethingchanged = false;
        for (int x = 0; x < getNumSignals(); x++) {
            if (sig[x].runTime() == RRSignal::EXPIRED) {
                sig[x].report();
                somethingchanged = true;
            }
        }
        // knock down signals ...'''
    print ""
    for item in me["sig"]:
        name=str(me["sig"][item]["longname"])
        print "\tsomethingchanged |= knockdownSignal(" + name + ");"
    print ""
    for item in me["sig"]:
        headlist=me["sig"][item]["heads"]
        for head in headlist:
            name = me["sig"][item][str(head)+"longname"]
            sys.stdout.write("\thead[" + name + "].set((RRSignalHead::Aspects)determineAspect("+ name +"));\n")
    print '''
        return somethingchanged;
}

boolean handleControlPacket(int src, int dst, int *controls, boolean force) {
        boolean cc = false;
        int safe = true;

        if (src == NODE_ME) {                           // I sent this one...
#ifdef DEBUG
                  Serial.println(" (Ignoring my loopback Indication Packet...)");
#endif
        } else if ((src != NODE_CTC) && (src != NODE_LOCAL)) {                   // Don't pay attention to gossip :-)
#ifdef DEBUG
                  Serial.println(" (Ignoring other unit's Indication Packet...)");
#endif
        } else if (dst != NODE_ME) {           // for someone else...
#ifdef DEBUG
                  Serial.println(" (Ignoring other unit's Control Packet...)");
#endif
        } else {                                        // for me!
                int idxN, offN;
                int idxS, offS;
                cc = true;

                // Is this a safe command?'''
    print ""
    print "\t\t//   Plant must be empty (switches not fouled...)"
    for item in me["sw"]:
        print "\t\tsafe &= !track[" + str(me["sw"][item]["tclongname"]) + "].is(TrackCircuit::OCCUPIED);"
    print ""
    print "\t\t//   Control packet must make sense"
    for item in me["sw"]:
        swname=str(me["sw"][item]["longname"])
        swNname=me["sw"][item]["control"]["normallongname"]
        swRname=me["sw"][item]["control"]["reverselongname"]
        print "\t\tsafe &= sw["+swname+"]\t.isSafe(&controls[toByte("+swNname+")], toBit("+swNname+"), toBit("+swRname+ ") );"
    print ""
    for item in me["sig"]:
        signame=str(me["sig"][item]["longname"])
        sigSTOPname=str(me["sig"][item]["control"]["stoplongname"])
        sigNname=str(me["sig"][item]["control"]["northlongname"])
        sigSname=str(me["sig"][item]["control"]["southlongname"])
        print "\t\tsafe &= sig["+signame+"].isSafe("
        print "\t\t\tbitRead(controls[toByte(" +sigSname+")], toBit("  +sigSname+")), "
        print "\t\t\tbitRead(controls[toByte(" +sigNname+")], toBit("  +sigNname+")) );"
    print ""
    print "\t\t// can only change FLEET stick and MC lights while plant is occupied"

    if len(me["mc"]):
        for item in me["mc"]:
            f=str(me["mc"][item]["field"])
            mcname=str(me["mc"][item]["longname"])
            mcCname=str(me["mc"][item]["controllongname"])
            print "\t\tmc["+mcname+"].set(bitRead(controls[toByte("+mcCname+")], toBit("+mcCname+")));"
        print "\t}"

    else:
        print "\t\t// There is no MC defined for this CP"
    print '''
        // TODO: Need to deal with fleet controls
        if (force) safe=1;  // At startup, force the CP to initialize into the last saved state
        if (!safe) {
#ifdef DEBUG
            Serial.println("VITAL level plant reject");
#endif
#ifdef HASLCD
            lcd.setCursor(17,  0); lcd.print("VR");
#endif
        } else {  // valid control packet...
#ifdef HASLCD
            lcd.setCursor(17,  0); lcd.print("OK");
#endif
            for (int x = 0; x <  getNumSwitches(); x++) {
                sw[x].doSafe();
            }
            for (int x = 0; x <   getNumSignals(); x++) {
                sig[x].doSafe();
            }
            ControlPoint::savestate(controls);  // remember last commanded turnout state in eeprom...
        }
        return cc;
}

void collectAndSendIndications(void) {
        int indications[8];

        for (int x = 0; x < 8; x++) {
            indications[x] = B00000000;
        }
        // Switches'''
    for item in me["sw"]:
        name  =me["sw"][item]["longname"]
        iNname=me["sw"][item]["indication"]["normallongname"]
        iRname=me["sw"][item]["indication"]["reverselongname"]
        print "\tbitWrite(indications[toByte("+iNname+")], toBit("+iNname+"), sw["+name+"].is(Switch::NORMAL));"
        print "\tbitWrite(indications[toByte("+iRname+")], toBit("+iRname+"), sw["+name+"].is(Switch::REVERSE));"

    print "\t// Track Circuits"
    for item in me["tc"]:
        name  = me["tc"][item]["longname"]
        iname = me["tc"][item]["indicationlongname"]
        print "\tbitWrite(indications[toByte("+iname+")], toBit("+iname+"), track["+name+"].is(TrackCircuit::OCCUPIED));"

    print "\t// Signals"
    for item in me["sig"]:
        name    = me["sig"][item]["longname"]
        iNname  = me["sig"][item]["indication"]["northlongname"]
        iSname  = me["sig"][item]["indication"]["southlongname"]
        print "\tbitWrite(indications[toByte("+iSname+")], toBit("+iSname+"), sig["+name+"].leftindication());\t// SIGNALS"
        print "\tbitWrite(indications[toByte("+iNname+")], toBit("+iNname+"), sig["+name+"].rightindication());\t// AT STOP?"

    print '''
    (void)ControlPoint::sendCodeLine(NODE_ME, NODE_CTC, indications);
}

#ifdef HASLCD
void lcdprintbin(byte x) {
    char buff[8+1];
    for (int i = 0; i < 8; i++) {
    buff[i] = (bitRead(x,i) ? '1' : '0');
    }
    buff[8] = '\0';
    lcd.print(buff);
}
#endif

'''
    if ("debugCallback" in me["code"]):
        print me["code"]["debugCallback"]["code"]
    else :
        print "void debugCallBack(boolean somethingchanged) { return; }     // Routine not found in CP definition"

    print '''
// boilerplate 'duino routines; CP specifics are encapsulated in common code in ControlPoint::setup and ControlPoint::loop

void setup(void)
{
#ifdef DEBUG
    // Configure the serial port
    Serial.begin(115200);    while (!Serial);
    Serial.println(ME);
    Serial.print("Free RAM: "); Serial.print(ControlPoint::freeRam(), DEC); Serial.println("");
#endif
#ifdef HASLCD
    lcd.begin(20,4);               // initialize the lcd
    lcd.setBacklight(HIGH);
    lcd.home();
    lcd.print(ME);
#endif
    ControlPoint::initializeCodeLine(LNET_RX_PIN,LNET_TX_PIN);
    Wire.begin();
    initI2Cextender(m);
    ControlPoint::setup();
'''
    print "\t// Set all Signals to allow local panel overrides for now"
    for item in me["sig"]:
        name    = me["sig"][item]["longname"]
        print "\tsig["+name+"].local(true);  // when plant is occupied, show STOP (false) or RESTRICTING (true) ?"
    print '''
}

int controls[8];
int src, dst;

void loop(void) {
    boolean somethingChanged = false;
    somethingChanged = ControlPoint::readall();
    int cc = ControlPoint::LnPacket2Controls(&src, &dst, controls);                       // 0 = no packet
    if (cc == 1) { somethingChanged |= handleControlPacket(src, dst, controls, false); }  // 1 = routine use, checkplant safety
    if (cc == 2) { somethingChanged |= handleControlPacket(src, dst, controls, true ); }  // 2 = startup with old configuration
    somethingChanged |= processSignals();

    if (somethingChanged) {
        collectAndSendIndications();
    }
    debugCallBack(somethingChanged);
    ControlPoint::writeall();
}'''
    print ""

# -------------------------------------------------------------------------------

cpdict = {}
me = controlpoint.ingest.read("cp_christopher.xml")
cpname = me["cpname"]
cpdict[cpname] = me

printHeader(me)

print controlpoint.format.include("Arduino.h")
print controlpoint.format.include("EEPROM.h")
print controlpoint.format.include("Wire.h")
print controlpoint.format.include("LocoNet.h")
print controlpoint.format.include("I2Cextender.h")
print controlpoint.format.include("elapsedMillis.h")
print controlpoint.format.include("ControlPoint.h")
print controlpoint.format.include(cp["layoutname"] + ".h")
print ""
print "#define {}\t\"{}\"".format("ME",                         me["cpname"])
print "#define {}\t{}".format("NODE_" + me["cpname"].upper(), str(me["nodenumber"]))

printDefinitions(me)
printFunctions(me)


