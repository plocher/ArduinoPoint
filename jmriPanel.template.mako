    def toJMRIPanel(self, fieldname, codeline):
        def define(a, b):
            return '#define {:<35}\t{}\n'.format(a, b)

        def walk(list, count=True):
            s = ''
            counter = 0
            for k, v in list.items():
                if count:
                    s += define(v.fullname, counter)
                else:
                    s += define(v.fullname, v.fieldvalue)
                counter += 1
            return s

        if cp and cp.ctcpanel:
            output = StringIO()

            f = cp.field.children[fieldname]

            output.write('#!/bin/sh\n')
            output.write('#    Autogenerated JMRI Panel generator for\n')
            output.write('#    ************************************\n')
            output.write('#    {:^34}\n'.format(cp.name + ' Field Unit'))
            output.write('#    ************************************\n')
            output.write('#    on: {}\n'.format(datetime.datetime.today().strftime('%Y-%m-%d %H:%M')))
            output.write('#\n')
            output.write('. ../../JMRI/createpanel.sh    # library routines to build panel\n')
            output.write('#\n')

            count = 0
            for _, CP in iter(natsorted(cp.ctcpanel.children.items())):
                for _, COL in iter(natsorted(CP.children.items())):
                    count = count + 1

            output.write('start=12\n')
            output.write('add=65\n')
            output.write('numcols={}\n'.format(count + 1))

            output.write('emitProlog\n')
            output.write('emitStartSensors\n')

            for _, CP in iter(natsorted(cp.ctcpanel.children.items())):
                output.write('# {cp} \n'.format(cp=CP.name))
                for _, COL in iter(natsorted(CP.children.items())):
                    output.write("# Column: {}\n".format(COL.name))
                    for _, ITEM in iter(natsorted(COL.children.items())):
                        d = dict(cp=CP.name, n=ITEM.name, d=COL.device, field=cp.name, f=ITEM.cpname, col=COL.name,
                                 l=ITEM.label, pos=ITEM.position)
                        # output.write('# n={n} d={d} field={field} f={f} col={col} l={l} pos={pos} \n'.format(**d))
                        if ITEM.mytype == "code":
                            output.write('createSensor  {cp}_CODE\n'.format(**d))
                        if ITEM.mytype == "call":
                            output.write('createSensor  {n}\n'.format(**d))
                            output.write('createSensor  {n}K\n'.format(**d))
                        if ITEM.mytype == "signal":
                            output.write('createSensor  {n}\n'.format(**d))
                            output.write('createSensor  {n}SGK\n'.format(**d))
                            output.write('createSensor  {n}NGK\n'.format(**d))
                            output.write('createSensor  {n}TEK\n'.format(**d))
                        if ITEM.mytype == "lock":
                            output.write('createSensor  {n}\n'.format(**d))
                            output.write('createSensor  {n}NWK\n'.format(**d))
                            output.write('createSensor  {n}RWK\n'.format(**d))
                        if ITEM.mytype == "switch":
                            output.write('createSensor  {n}\n'.format(**d))
                            output.write('createSensor  {n}NWK\n'.format(**d))
                            output.write('createSensor  {n}RWK\n'.format(**d))
                        if ITEM.mytype == "model":
                            output.write('createSensor  {n}K\n'.format(**d))
                output.write('\n')

            output.write('emitFinishSensors\n')
            output.write('emitStartPanel 0 "$(( (1 + numcols) * add + (start * 3) ))"\n')

            for _, CP in iter(natsorted(cp.ctcpanel.children.items())):
                output.write('# {cp} \n'.format(cp=CP.name))
                for _, COL in iter(natsorted(CP.children.items())):
                    output.write("# Column: {col}\n".format(col=COL.name))
                    output.write('col=$(( ({col} - 1) * add + start ))\n'.format(col=COL.name))
                    output.write('createPanelBackground "$col"\n')
                    for _, ITEM in iter(natsorted(COL.children.items())):
                        '''
                                General format

                                name, control packet details, ind packet details, PANEL inputs, PANEL outputs
                        '''
                        d = dict(cp=CP.name, n=ITEM.name, d=COL.device, field=cp.name, f=ITEM.cpname, col=COL.name,
                                 l=ITEM.label, pos=ITEM.position)
                        # output.write('# n={n} d={d} field={field} f={f} col={col} l={l} pos={pos} \n'.format(**d))
                        if ITEM.mytype == "code":
                            output.write('createCodeButton  "$col" {cp}_CODE\n'.format(**d))
                        if ITEM.mytype == "call":
                            output.write('createMC          "$col" {n}  {n}K\n'.format(**d))
                        if ITEM.mytype == "signal":
                            output.write('createSigPlate    "$col" {n}  {n}SGK  {n}NGK  {n}TEK\n'.format(**d))
                        if ITEM.mytype == "lock":
                            output.write('createLockPlate   "$col" {n}  {n}NWK  {n}RWK\n'.format(**d))
                        if ITEM.mytype == "switch":
                            output.write('createSwitchPlate "$col" {n}  {n}NWK  {n}RWK\n'.format(**d))
                        if ITEM.mytype == "model":
                            output.write(
                                'createModel       "$col" {n}K {color} {pos}\n'.format(n=ITEM.name, color=ITEM.color,
                                                                                       pos=ITEM.position))
                output.write('\n')
            output.write('\n')
            # output.write('xxx\n')
            output.write('emitFinishPanel "$(( (numcols - 1) * add + start))"\n')
            output.write('emitEpilog\n')
            output.write('\n')
            contents = output.getvalue()
            output.close()
            return contents
